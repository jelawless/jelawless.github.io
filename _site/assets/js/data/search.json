[
  
  {
    "title": "PCB StreamDeck",
    "url": "/posts/StreamDeck/",
    "categories": "Electronics Project, PCBs, User Inerface Design, Prototyping and Development",
    "tags": "Microcontroller, Programming, CircuitPython, Hardware Prototyping, Raspberry Pi Pico, DIY Project",
    "date": "2024-04-03 21:33:00 -0600",
    





    
    "snippet": "IntroThis project details the creation of a custom macro keypad, affectionately dubbed the “PicoDeck,” built around the Raspberry Pi Pico. It features mechanical keyboard switches for tactile input...",
    "content": "IntroThis project details the creation of a custom macro keypad, affectionately dubbed the “PicoDeck,” built around the Raspberry Pi Pico. It features mechanical keyboard switches for tactile input and a rotary encoder for intuitive media control. The device leverages CircuitPython, chosen for its ease of use and robust file system access, enabling straightforward customization of macros and keymaps. A custom Human Interface Device (HID) library facilitates its function as a versatile keyboard and media controller, while a self-designed PCB ensures a clean and integrated build.PicoDeck Build DetailsCore ComponentsBelow is a list of the primary components used to build the PicoDeck.  Raspberry Pi Pico  Mechanical Keyboard Switches (e.g., Cherry MX, Gateron, Kailh)  Keycaps (Compatible with chosen switches)  Rotary Encoder (EC11 type with push button)  Custom PCB (Designed in KiCad)  USB Cable (Micro USB for Pico)  (Optional) 3D Printed EnclosureRaspberry Pi Pico  Description  The Raspberry Pi Pico is a low-cost, high-performance microcontroller board featuring the RP2040 chip. It was selected for this project due to its native USB support, ample GPIO pins, and excellent compatibility with CircuitPython. CircuitPython allows the Pico to appear as a USB mass storage device, making code updates as simple as editing a Python file.   Part List  Raspberry Pi Pico (https://www.raspberrypi.com/products/raspberry-pi-pico/)  Software Setup  CircuitPython must be flashed onto the Pico. This involves holding the BOOTSEL button while plugging it into a computer, then dragging the CircuitPython UF2 file onto the RPI-RP2 drive. Essential CircuitPython libraries, particularly adafruit_hid for keyboard and consumer control (media keys), and rotaryio for the encoder, are then copied to the lib folder on the CIRCUITPY drive.  Summary of Setup  Download the correct CircuitPython UF2 for the Pico. Enter BOOTSEL mode on the Pico. Copy the UF2 file. Install necessary libraries (adafruit_hid, rotaryio, adafruit_debouncer) into the lib folder on the CIRCUITPY drive.  Note: Ensure you download the latest stable version of CircuitPython and the corresponding library bundle from Adafruit to maintain compatibility and access the latest features.  Results  The Pico serves as the brain of the macro pad, running the CircuitPython code that scans for key presses and rotary encoder movements, and then sends the appropriate HID commands to the connected computer.Mechanical Keyboard Switches &amp; Keycaps  Description  Mechanical keyboard switches provide superior tactile feedback and durability compared to membrane keys. A variety of switch types (linear, tactile, clicky) can be chosen based on user preference. Keycaps are placed on top of the switches and can be customized for aesthetics and labeling. For this project, 4 switches were used.    Part List            Mechanical Keyboard Switches (e.g., Gateron Browns, Cherry MX Reds)      Keycaps (MX-stem compatible, desired profile)        Assembly  Switches are typically press-fit into a compatible PCB or plate. If using a custom PCB, they will need to be soldered to the board. Keycaps are then pressed onto the switch stems.  Summary of Assembly  Mount switches onto the PCB. Solder switch pins to the PCB pads. Attach keycaps to the switches.  Note: Choose switches that match your desired feel and sound profile. Ensure keycaps are compatible with the switch stems (MX-style is most common). Careful soldering is required to avoid damaging switches or the PCB.  Results  Provides reliable and customizable physical inputs for triggering macros, shortcuts, or application commands. The tactile feel enhances the user experience.Rotary Encoder (EC11 with Push Button)  Description  An EC11-type rotary encoder allows for incremental adjustments (like volume control) and often includes a push-button switch (used here for play/pause). It provides a versatile input method beyond simple key presses.    Part List  EC11 Rotary Encoder with push-button (https://www.adafruit.com/product/377 or similar)          Knob for the encoder shaft        Assembly &amp; Software  The encoder is soldered to the PCB. In CircuitPython, the rotaryio library is used to read rotational changes, and digitalio along with adafruit_debouncer is used to read the push-button state. These inputs are then mapped to Consumer Control HID codes for volume up/down and play/pause.  Summary of Integration  Solder encoder to PCB. In code.py, initialize rotaryio.IncrementalEncoder for rotation and digitalio.DigitalInOut with adafruit_debouncer.Debouncer for the button. Map encoder events to HID media commands.  Note: Debouncing the push-button is crucial for reliable operation. The rotaryio library simplifies reading the encoder’s A/B phase signals. Ensure the encoder pins are correctly wired to the Pico’s GPIOs as defined in your code.py.  Results  Enables intuitive control over system volume by rotating the knob and play/pause functionality for media by pressing the knob.Custom PCB (KiCad Design)  Description  A custom Printed Circuit Board (PCB) was designed using KiCad EDA software. This allows for a compact and clean integration of the Raspberry Pi Pico, keyboard switches, rotary encoder, and any necessary supporting components (like diodes for a key matrix, if implemented). It eliminates messy point-to-point wiring.    Part List            Custom PCB (fabricated from Gerber files generated by KiCad)      (Optional) Diodes (e.g., 1N4148) if implementing a key matrix.      Headers for Pico (optional, can solder Pico directly).        Design &amp; Fabrication  The PCB layout involves placing footprints for all components, routing traces to connect them according to the schematic, and then generating Gerber files. These Gerbers are sent to a PCB fabrication house (e.g., JLCPCB, PCBWay, OSH Park) for manufacturing.  Summary of Process  Design schematic in KiCad. Lay out components and route traces on PCB. Generate Gerber files. Order PCB from a fabrication service. Solder all components onto the received PCB.  Note: Designing a PCB can have a learning curve. Pay close attention to component footprints, trace widths, and clearance rules. For a key matrix, ensure correct diode orientation. Thoroughly check your design before sending it for fabrication to avoid costly errors.  Results  A professional-looking and robust platform for all components. Simplifies assembly, improves reliability, and provides a solid foundation for the macro pad.CircuitPython &amp; Custom HID Programming  Description  CircuitPython was chosen for its Pythonic syntax, ease of iteration (code changes are live on save), and excellent library support. The adafruit_hid library is pivotal, providing classes to emulate a keyboard (Keyboard), mouse (Mouse), and consumer control device (ConsumerControl). This allows the PicoDeck to send standard keyboard shortcuts, type text, and control media playback.   Software Components            CircuitPython firmware for Raspberry Pi Pico      adafruit_hid CircuitPython library      rotaryio CircuitPython library      adafruit_debouncer CircuitPython library      Custom code.py script        Implementation  The main code.py script initializes the GPIO pins connected to switches and the rotary encoder. It runs a loop that:          Scans the state of each switch.      Reads the rotary encoder’s position and button state.      Based on detected inputs, uses the adafruit_hid.Keyboard object to send key presses/combinations (e.g., kbd.send(Keycode.CONTROL, Keycode.C)) or the adafruit_hid.ConsumerControl object to send media commands (e.g., cc.send(ConsumerControlCode.VOLUME_INCREMENT)).        Summary of Code Logic  Initialize HID devices (Keyboard, ConsumerControl). Configure GPIO pins for inputs. In the main loop, read all inputs. If an input event occurs (key press, encoder turn/press), send the corresponding HID report.  Note: To make the Pico appear as a composite HID device (e.g., keyboard + media controller), you might need to create a custom boot.py file to define the USB descriptors, or ensure your CircuitPython version handles this gracefully with multiple adafruit_hid device instances. The file system access of CircuitPython means you can easily edit code.py to change key mappings without re-flashing firmware.  Results  A highly customizable macro pad that can send complex keyboard shortcuts, type predefined strings, control applications, and manage media playback seamlessly on any computer that supports USB HID devices.Full Build Guide &amp; ResourcesFor those interested in building their own PicoDeck, a more comprehensive step-by-step guide, including KiCad project files, and CircuitPython code examples, will be made available.This detailed documentation will cover:  KiCad: Schematic and PCB layout walkthrough, Gerber generation.      CircuitPython: Full code.py examples for key scanning (direct IO or matrix), rotary encoder handling, debouncing, and sending various HID commands. Configuration for custom keymaps.    Link to Guide"
  },
  
  {
    "title": "Modified Ender 3 with Klipper - 3x Speed Improvement Case Study",
    "url": "/posts/Klipper/",
    "categories": "3D Printing, 3D Printer Upgrades, Ender 3 Mods, Klipper Firmware",
    "tags": "Ender 3, Klipper, Firmware Upgrade, 3D Printer Tuning",
    "date": "2023-05-09 21:33:00 -0600",
    





    
    "snippet": "Project OverviewThe Challenge: The stock Ender 3 was limited to 50mm/s print speeds with noticeable quality degradation beyond that threshold. A typical functional part required 12+ hours of print ...",
    "content": "Project OverviewThe Challenge: The stock Ender 3 was limited to 50mm/s print speeds with noticeable quality degradation beyond that threshold. A typical functional part required 12+ hours of print time, and the printer suffered from Z-axis inconsistencies and poor retraction control with the Bowden extruder setup.The Goal: Achieve 3x speed improvement while maintaining or improving dimensional accuracy and surface quality. Additionally, reduce operational noise and enable advanced features like real-time bed leveling and automatic flow control.The Outcome: Successfully achieved 150mm/s reliable print speeds with improved ±0.05mm dimensional accuracy. Reduced typical print times from 12 hours to 4 hours while cutting operational noise by 35%. The printer now handles flexible filaments reliably and features real-time mesh bed leveling.Performance Summary            Metric      Before      After      Improvement                  Max Reliable Speed      50mm/s      150mm/s      3x faster              Typical Print Time      12 hours      4 hours      66% reduction              Operational Noise      65dB      42dB      35% quieter              Dimensional Accuracy      ±0.15mm      ±0.05mm      3x more precise              Retraction Distance      6-8mm      0.5-1.5mm      85% reduction              Max Volumetric Flow      8mm³/s      30mm³/s      2.75x increase              Flexible Filament      Not reliable      Fully capable      New capability      Technical ApproachThis project centered on identifying and eliminating the key bottlenecks preventing high-speed printing: motion control limitations, insufficient cooling, slow filament melting, and mechanical instability. Each upgrade was chosen to address a specific bottleneck while maintaining system compatibility.Strategic Upgrade Philosophy  Foundation First: Upgraded motion control (Klipper + SKR Mini E3) before pushing speed limits  Remove Bottlenecks: Identified that hotend melt rate and part cooling were limiting factors  Mechanical Stability: Ensured the frame could handle increased accelerations  Iterative Tuning: Each upgrade was tested individually to verify improvementsKey ModificationsKlipper Firmware on Raspberry Pi 3B+Why This UpgradeThe stock Ender 3 mainboard uses an 8-bit processor that struggles with advanced motion planning algorithms. Klipper offloads computational tasks to a Raspberry Pi, enabling Input Shaping (reduces ringing artifacts), Pressure Advance (improves corners), and higher acceleration values without motion artifacts.Implementation ChallengeRequired flashing MainsailOS to the Raspberry Pi, establishing USB communication with the mainboard, and tuning over 200 configuration parameters in printer.cfg. Input Shaping calibration required running accelerometer tests to find optimal shaping frequencies (mine settled at 42Hz for X and 38Hz for Y).Measured Impact  Enabled 3000mm/s² acceleration (up from 500mm/s²)  Eliminated ringing artifacts at high speeds  Added web-based remote control and real-time monitoring  Reduced corner bulging by 75% through Pressure Advance tuningTechnical Details  Hardware: Raspberry Pi 3B+, 32GB SD card, 5V/2.5A power supply  Software: MainsailOS (Klipper + Mainsail web interface)  Configuration: Custom printer.cfg with Input Shaping enabled  Key Settings: max_accel: 3000, square_corner_velocity: 5.0  Learning: Klipper’s power comes from its ability to calculate motion plans in advance on powerful hardware. The tuning process taught me the importance of measuring (accelerometer data) rather than guessing optimal settings.BDsensor - Real-Time Bed LevelingWhy This UpgradeTraditional bed leveling (like BLTouch) only probes before printing. The BDsensor continuously monitors distance to the bed during printing, compensating for any bed warping, thermal expansion, or first-layer adhesion issues in real-time.Implementation ChallengeThe sensor uses eddy current detection and required precise mounting to maintain 2-3mm distance from the bed. Integration with Klipper required custom configuration following the official integration guide. The sensor’s cable is fragile and required careful strain relief.Measured Impact  First layer consistency improved from ±0.08mm to ±0.02mm variation  Eliminated need for constant manual bed leveling adjustments  Reduced failed prints due to bed adhesion issues by ~80%  Bed mesh generation time: 15 seconds (vs. 3-5 minutes with BLTouch)Technical Details  Hardware: BDsensor with magnetic coil from PandaPi3D  Mounting: Custom integrated into Apollolander cooling shroud  Calibration: Required z-offset calibration and sensitivity tuning  Troubleshooting Note: After Klipper software updates, the BDsensor occasionally fails to initialize. Solution: recompile and reflash the .bin firmware to the SKR Mini E3 V3 board.SKR Mini E3 V3 MotherboardWhy This UpgradeThe stock 8-bit Creality board limited processing power and used older, noisier stepper drivers. The SKR Mini E3 V3 provides a 32-bit STM32 processor and integrated TMC2209 silent stepper drivers, enabling Klipper to execute complex motion plans smoothly while dramatically reducing motor noise.Implementation ChallengeDirect drop-in replacement, but required careful pin mapping in Klipper configuration. Stealth Chop mode on TMC2209 drivers needed tuning to avoid skipped steps at high accelerations. Compiled custom Klipper firmware binary specifically for the STM32G0B1 chip.Measured Impact  Reduced stepper motor noise from 65dB to 42dB (35% quieter)  Enabled higher microstepping (256x vs. 16x) for smoother motion  Improved thermal management with active cooling on drivers  Faster G-code processing allowing higher movement speedsTechnical Details  Hardware: BIGTREETECH SKR Mini E3 V3 with TMC2209 drivers  Processor: STM32G0B1RET6 32-bit ARM Cortex-M0+  Drivers: TMC2209 in UART mode for runtime configuration  Key Feature: Sensorless homing capability (not yet implemented)Dual Z-Axis - Mechanical StabilityWhy This UpgradeThe stock single Z-axis lead screw caused the X-gantry to sag on the unsupported side, especially problematic with the added weight of a direct drive extruder. This sag caused inconsistent layer heights across the print bed width and potential Z-binding.Implementation ChallengeRequired precise gantry tramming (alignment) to prevent binding. Both Z motors needed synchronized movement, configured in Klipper as a mirrored axis. Proper tensioning of the belts and couplers was critical to avoid introducing new sources of mechanical error.Measured Impact  Eliminated visible Z-banding on tall prints  Reduced layer height variation across bed width from 0.12mm to 0.03mm  Enabled reliable support for 450g direct drive extruder weight  Improved print consistency on parts wider than 150mmTechnical Details  Hardware: Official Creality dual Z-axis kit with second stepper motor  Configuration: Configured as [stepper_z1] mirror in Klipper  Alignment: Manual tramming using precision measuring tools  Maintenance: Check synchronization monthly  Critical Setup: Proper gantry tramming is essential. Misalignment causes binding and layer inconsistencies. I use the “paper test” method on both sides before locking the couplers.Orbiter V2.0 Direct Drive ExtruderWhy This UpgradeThe Bowden extruder’s long filament path (400mm+) created lag between extruder commands and actual filament deposition. This caused poor retraction performance, stringing, and made flexible filament printing nearly impossible. Direct drive places the extruder motor directly on the hotend.Implementation ChallengeWeight was a concern (450g vs. 120g for Bowden), requiring the dual Z upgrade for support. The compact 7.5:1 geared design required precise rotation_distance calibration (found to be 4.637 through testing). Pressure Advance tuning was critical and required multiple test prints to dial in optimal values.Measured Impact  Reduced retraction distance from 6-8mm to 0.5-1.5mm (85% reduction)  Eliminated stringing on fast travel moves  Enabled reliable TPU/flexible filament printing  Improved corner accuracy through faster pressure response  Reduced oozing during non-print moves by 90%Technical Details  Hardware: Orbiter V2.0 with 7.5:1 planetary gearbox  Motor: LDO-36STH20-1004AHG pancake stepper  Calibration: rotation_distance: 4.637, Pressure Advance: 0.035  Weight: 450g including mounting bracket  Tuning Insight: Direct drive changes everything about retraction and pressure advance. Started with recommended values from Orbiter docs, then fine-tuned using Klipper’s PA calibration pattern. Sweet spot was 0.035 for PLA.Custom Hotend Cooling - Apollolander Dual 5015Why This UpgradeAt high print speeds, the plastic must solidify quickly to maintain shape, especially on overhangs and bridges. The stock single 4010 fan provided insufficient airflow, limiting practical print speeds to around 60mm/s even with proper hotend temperature. Part cooling was the identified bottleneck.Implementation ChallengeThe Apollolander shroud required printing in PETG for heat resistance. Dual 5015 blower fans draw significant power and required proper wiring to dedicated fan ports. Airflow is so strong that fan speed often runs at 30-50% for PLA to avoid warping.Measured Impact  Enabled clean overhangs at 70° angles at 150mm/s speeds  Reduced bridging failures from 40% to &lt;5%  Allowed aggressive layer times (3-4 second minimum layer time)  Improved surface finish quality on complex geometries  400% increase in cooling airflow (measured with anemometer)Technical Details  Hardware: Two 5015 24V radial blower fans, PETG printed shroud  Design: Custom modified Apollolander with BDsensor integration  Configuration: PWM fan control, typically run at 35-60% for PLA  Power Draw: ~4.8W per fan at full speed  Material Note: For PETG and ABS, excessive cooling causes layer adhesion issues. I typically run fans at 0-30% for these materials, showing the importance of having variable speed control.CHT (Core Heating Technology) NozzleWhy This UpgradeEven with improved cooling and direct drive, the hotend couldn’t melt filament fast enough at high speeds. The bottleneck shifted to volumetric flow rate. The CHT nozzle’s internal geometry splits filament into three strands, dramatically increasing surface area contact with heated walls.Implementation ChallengeRequired flow rate testing to determine new maximum capabilities. Retested temperature towers since the improved melting efficiency meant I could lower temperatures while maintaining quality. Ran volumetric flow tests up to failure point to find safe operational limits.Measured Impact  Increased max volumetric flow from 8mm³/s to 24mm³/s (3x improvement)  Enabled 150mm/s print speeds with 0.4mm nozzle at 0.2mm layer height  Reduced minimum hotend temperature for PLA from 215°C to 205°C  Eliminated under-extrusion issues at high speeds  Key enabler for the overall speed target achievementTechnical Details  Hardware: Bondtech CHT Coated Brass 0.4mm  Flow Testing: Achieved 24mm³/s before quality degradation  Temperature: PLA at 205-210°C, PETG at 235-240°C  Alternative: AliExpress CHT clones perform within 10% of original  Cost Discovery: Testing showed that CHT clones from AliExpress achieved 22mm³/s flow rates (vs. 24mm³/s for genuine Bondtech) at 1/4 the price. For hobbyist use, the clones offer excellent value.Meanwell LRS-350-24 PSUWhy This UpgradeThe stock PSU was bulky and had occasional voltage stability issues under high load (all fans + heated bed + steppers). The Meanwell unit provides cleaner power delivery, better efficiency, and frees up vertical space for potential enclosure installation.Implementation ChallengeRequired relocating and rewiring the power connections. Critical safety check: voltage selector switch defaults to 240V and must be manually switched to 120V for US operation.Measured Impact  Improved voltage stability during high-load operations  Freed up 60mm vertical space underneath printer  Reduced power supply operating temperature by ~15°C  Better protection features (over-current, over-voltage, short circuit)  Increased overall system reliabilityTechnical Details  Hardware: Meanwell LRS-350-24 (24V, 14.6A)  Efficiency: ~90% vs. ~80% for stock PSU  Safety: Built-in overload and short circuit protection  Form Factor: 215 x 115 x 30mm (vs. 150 x 215 x 85mm stock)  CRITICAL SAFETY: Verify voltage selector switch is set to 120V before powering on if you’re in the US. The switch defaults to 240V during shipping. Incorrect voltage will damage the PSU.Capricorn PTFE TubingWhy This UpgradeHigh-quality PTFE tubing reduces friction and compression, improving filament path consistency. While less critical with direct drive, a short segment guides filament into the extruder entrance, preventing binding.ImplementationUsed a 20mm segment of Capricorn tubing as a filament guide between the spool holder and extruder entrance. With direct drive, the long Bowden tube is eliminated entirely.Impact  Smooth filament feeding with reduced friction  Prevents filament kinking at extruder entrance  Maintains consistent path during high-speed retractionsTechnical Details  Hardware: Capricorn XS tubing  Length Used: ~20mm segment only  Inner Diameter: 1.9mm (vs. 2.0mm stock) for tighter tolerancesKey Learnings &amp; TakeawaysWhat Worked Well  Systematic bottleneck identification: Measuring performance after each upgrade revealed which changes actually mattered  Foundation-first approach: Installing Klipper and the SKR board early provided the platform for everything else  Iterative tuning: Small calibration improvements accumulated to significant performance gainsWhat I’d Do Differently  Start with dual Z: Installing this earlier would have prevented some early print quality issues  Budget for measurement tools: Accelerometer and thermal camera would have shortened tuning time  Document baseline metrics: I didn’t record enough “before” data for perfect comparisonTransferable Skills Gained  Firmware compilation and embedded systems configuration  Systematic debugging methodology for multi-component systems  Understanding acceleration physics and motion control algorithms  Balancing performance trade-offs (speed vs. quality vs. reliability)Future Improvements Being Considered  Linear rails on X and Y axes for even higher accelerations  Enclosed chamber for ABS/ASA printing  Automatic filament switching for multi-color prints  Raspberry Pi upgrade to Pi 4 for camera streamingConclusionThis project achieved its primary goal of 3x speed improvement while simultaneously improving print quality and reliability. The systematic approach of identifying bottlenecks, implementing targeted upgrades, and iteratively tuning parameters resulted in a machine that feels entirely different from the stock Ender 3.Most Impactful Upgrades (in order):  Klipper firmware - Enabled everything else  CHT nozzle - Removed the flow rate bottleneck  Orbiter V2.0 direct drive - Transformed extrusion control  Dual 5015 cooling - Enabled high-speed overhangsThe total investment was approximately $450 in parts and ~60 hours of work, reducing average print times from 12 hours to 4 hours. This breaks even after ~170 prints, while significantly expanding the printer’s capabilities into flexible filaments and complex geometries.Resources &amp; References  Klipper Documentation  Orbiter V2.0 Configuration  BDsensor Integration Guide  Ellis’ Print Tuning Guide - Invaluable for Klipper calibration  Teaching Tech Calibration - Used for flow and e-step calibration"
  }
  
]

